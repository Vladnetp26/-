1. Допустим, у вас есть файл с данными, который называется ‘iris.csv’. Этот файл находится в папке ‘/data/’. Вы открываете его
в текстовом редакторе и видите следующие первые строки sepal length in cm; sepal width in cm; petal length in cm; petal width in cm; class 5.1; 3.5; 1.4; 0.2; 0
Как должна выглядеть команда для считывания данных в датафрейм Pandas?

-Чтобы импортировать информацию из файла iris.csv в датафрейм Pandas, где данные разделены точкой с запятой (;), можно применить метод read_csv из библиотеки Pandas. Необходимо обратить особое внимание на указание корректного разделителя, так как по умолчанию функция read_csv предполагает использование запятой (,) для разделения значений.
Кроме того, следует проверить наличие пробелов после разделителей в вашем файле, если таковые имеются, и учесть это при импорте данных.
 
Ниже представлен образец кода для импорта данных из вашего файла:

import pandas as pd

# Импорт информации из файла
путь_к_файлу = '/data/iris.csv'
датафрейм = pd.read_csv(путь_к_файлу, sep=';')

# Отображение начальных строк датафрейма
print(датафрейм.head())
Этот скрипт демонстрирует, как использовать библиотеку pandas для загрузки данных из CSV-файла с разделителем в виде точки с запятой, а затем показывает первые несколько строк полученного датафрейма.

Разбор структуры кода:
1. Подключение библиотеки: Начинаем с импорта Pandas, присваивая ей краткое имя pd для удобства использования.
2. Определение расположения файла: Создаем переменную file_path, содержащую путь к нашему CSV-файлу.
3. Извлечение информации: Применяем метод pd.read_csv() для загрузки данных. Параметр delimiter=';' играет ключевую роль, указывая на использование точки с запятой в качестве разделителя полей. Это критично для корректной интерпретации структуры файла, где столбцы разделены именно этим символом.
4. Проверка загруженных данных: Используем функцию data.head() для отображения первых пяти записей датафрейма. Это позволяет быстро оценить правильность загрузки и структурирования данных.

2. Для набора данных Cars после удаления дубликатов выберите из полного датафрейма строки с индекса 69 по 322. Отсортируйте полученный датафрейм по колонке ‘Distance’ по убыванию.
Какое значение колонки ‘Style’ у полученного датафрейма во второй строке сверху?

Для решения поставленной задачи в Python рекомендуется использовать библиотеку pandas. Следуйте этому алгоритму:

1. Импортируйте данные в структуру DataFrame.
2. Исключите повторяющиеся записи.
3. Извлеките строки с 69-й по 322-ю включительно.
4. Проведите сортировку полученного набора данных по столбцу 'Distance' в порядке убывания.
5. Определите значение в столбце 'Style' для второй строки отсортированного набора.

Этот подход позволит последовательно обработать данные и получить требуемый результат.
import pandas as pd

Пример кода:
# Этап 1: Импорт данных в DataFrame (предполагаем, что файл называется 'cars.csv')
датафрейм = pd.read_csv('cars.csv')

# Этап 2: Исключение повторяющихся записей
датафрейм = датафрейм.drop_duplicates()

# Этап 3: Извлечение строк с 69-й по 322-ю включительно
выборка = датафрейм.iloc[69:323]

# Этап 4: Упорядочивание по столбцу 'Distance' в порядке убывания
отсортированный_df = выборка.sort_values(by='Distance', ascending=False)

# Этап 5: Определение значения в столбце 'Style' для второй строки
стиль_второй_строки = отсортированный_df.iloc[1]['Style']

print(стиль_второй_строки)
Этот скрипт демонстрирует последовательность действий для обработки данных и извлечения нужной информации из DataFrame pandas.

Описание шагов:
1.Подключаем библиотеку pandas для работы с данными.
2. Используем функцию read_csv() для импорта информации из файла 'cars.csv' в структуру DataFrame.
3. Применяем метод drop_duplicates() для исключения повторяющихся записей.
4. Извлекаем нужный диапазон строк (с 69-й по 322-ю) с помощью функции iloc[]. Учитываем, что верхняя граница не включается, поэтому указываем 323.
5. Проводим сортировку DataFrame по столбцу 'Distance' в нисходящем порядке, устанавливая параметр ascending=False.
6. С помощью iloc[1] определяем значение в столбце 'Style' для второй строки отсортированного набора данных.
Этот алгоритм позволяет последовательно обработать данные и получить требуемую информацию из DataFrame.

3. Для набора данных Cars оцените количество строк, которые были удалены после анализа гистограмм распределения и удаления аномальных значений.

-Чтобы оценить количество строк, которые были удалены после анализа гистограмм распределения и удаления аномальных значений в наборе данных Cars, нужно выполнить следующие шаги:
1. Загрузите данные в DataFrame.
2. Постройте гистограммы для каждого интересующего столбца.
3. Определите критерии для исключения аномальных значений.
4. Удалите строки, соответствующие этим критериям.
5. Подсчитайте количество удаленных строк.
Код представлен ниже демонстрирует пример работы с данными и их визуализации с использованием библиотек Pandas и Matplotlib. В данном случае, мы работаем с файлом 'cars.csv', загружая его данные в DataFrame. Затем, выбирая интересующие нас столбцы (в данном случае 'Distance', 'Price' и 'Age'), мы создаем гистограммы для каждого из них, чтобы оценить распределение данных в данном столбце. На основе этого, мы можем выполнять анализ данных и находить текущие тенденciи.

Код:

# Импортируем необходимые библиотеки
import pandas as pd
import matplotlib.pyplot as plt

# Шаг 1: Загрузка данных из файла 'cars.csv' и сохранение их в DataFrame
data = pd.read_csv('cars.csv')

# Шаг 2: Определение интересующих нас столбцов и построение гистограмм для каждого из них
интересующие_столбцы = ['Distance', 'Price', 'Age']

for столбец in интересующие_столбцы:
    # Создание нового графика
    plt.figure()
    
    # Построение гистограммы для данного столбца
    data[столбец].hist(bins=50)
    
    # Добавление заголовка графика
    plt.title(f'Гистограмма значений {столбец}')
    
    # Установка названия оси X
    plt.xlabel(столбец)
    
    # Установка названия оси Y
    plt.ylabel('Частота')
    
    # Отображение графика
    plt.show()

# Шаг 3: Определение критериев для исключения аномальных значений
# Здесь мы используем метод межквартильного диапазона (IQR) для определения аномалий
def remove_outliers(df, column):
    Q1 = df[column].quantile(0.25)
    Q3 = df[column].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    return df[(df[column] >= lower_bound) & (df[column] <= upper_bound)]

# Шаг 4: Удаление строк, соответствующих критериям
initial_row_count = df.shape[0]
for column in columns_of_interest:
    df = remove_outliers(df, column)
final_row_count = df.shape[0]

# Шаг 5: Подсчет количества удаленных строк
rows_removed = initial_row_count - final_row_count
print(f'Количество удаленных строк: {rows_removed}')
Описание шагов:
1. Импортируйте pandas и matplotlib.pyplot библиотеки, которые необходимы для работы с данными и визуализации графиков.
2. Загрузите данные из файла 'cars.csv' в DataFrame, чтобы использовать его для дальнейших операций.
3. Создайте гистограммы для всех столбцов, которые интересуют вас (например, 'Distance', 'Price' и 'Age'), чтобы визуально оценить распределение данных и выявить возможные аномалии.
4. Определите критерии для исключения аномальных значений, используя метод IQR. Этот метод находит первый и третий квартили и вычисляет диапазон между ними, затем устанавливает границы для удаления аномалий.
5. Напишите функцию удалить_аномалии, которая принимает DataFrame и имя столбца и возвращает новый DataFrame без строк, содержащих аномальные значения в указанном столбце.
6. Подсчитайте количество строк до и после вызова функции удалить_аномалии для оценки количества удаленных строк. Это поможет определить, насколько успешно прошёлся процесс удаления аномалий.

4. Для набора данных Cars назовите самую распространенную марку автомобилей (столбец Make).

-Чтобы определить самую распространенную марку автомобилей в наборе данных Cars, можно использовать библиотеку pandas. Вот шаги, которые нужно выполнить:
1. Загрузите данные в DataFrame.
2. Подсчитайте количество появлений каждой марки.
3. Определите марку с наибольшим количеством появлений.
Пример кода:

import pandas as pd
# Шаг 1: Загрузка данных в DataFrame (предположим, что данные в файле 'cars.csv')
df = pd.read_csv('cars.csv')
# Шаг 2: Подсчет количества появлений каждой марки
make_counts = df['Make'].value_counts()
# Шаг 3: Определение марки с наибольшим количеством появлений
most_common_make = make_counts.idxmax()
most_common_make_count = make_counts.max()
print(f'Самая распространенная марка автомобилей: {most_common_make} (Количество: {most_common_make_count})')
Описание шагов:
1. Импортируем библиотеку pandas.
2. Загрузим данные из файла 'cars.csv' в DataFrame.
3. Применим метод value_counts() к столбцу 'Make', чтобы подсчитать количество вхождений каждой марки автомобилей.
4. Используем метод idxmax() для определения марки автомобиля с наибольшим количеством появлений, а метод max() для получения этого максимального значения.

5. Визуализируйте скаттерограмму для двух столбцов — Distance и Year — набора данных Cars с использованием столбца Transmission в качестве цвета маркера (hue). К какому типу
Transmission относится точка, которая наиболее близка к координатам (Year = 1980, Distance = 500 000)?

Для выполнения этой задачи мы будем использовать библиотеку Seaborn для построения скаттерограммы и библиотеку pandas для обработки данных. Вот шаги, которые необходимо выполнить:

1. Загрузите данные в DataFrame.
2. Постройте скаттерограмму, используя столбцы 'Distance' и 'Year', и используйте столбец 'Transmission' для цветовой кодировки (hue).
3. Найдите точку, которая наиболее близка к координатам (Year = 1980, Distance = 500000).
4. Определите тип трансмиссии для этой точки.
Пример кода:
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from scipy.spatial import KDTree

# Шаг 1: Загрузка данных из файла 'cars.csv' в DataFrame
df = pd.read_csv('cars.csv')

# Шаг 2: Построение скаттерограммы с использованием столбцов 'Year' и 'Distance', где 'Transmission' определяет цвет точек
plt.figure(figsize=(10, 6))
sns.scatterplot(
    data=df, 
    x='Year', 
    y='Distance', 
    hue='Transmission', 
    palette='viridis'
)
plt.title('Scatter Plot of Distance vs Year with Transmission as Hue')
plt.show()
# Шаг 3: Поиск точки, ближайшей к координатам (Year = 1980, Distance = 500000)
# Создаем KDTree для быстрого поиска ближайших точек
tree = KDTree(df[['Year', 'Distance']])
dist, idx = tree.query([[1980, 500000]], k=1)
nearest_point = df.iloc[idx[0]]
nearest_transmission = nearest_point['Transmission']
print(f'Тип Transmission для ближайшей точки к (Year = 1980, Distance = 500000): {nearest_transmission}')
Описание шагов:
1. Импортируйте необходимые библиотеки: pandas для данных, seaborn и matplotlib для визуализации, а также scipy.spatial.KDTree для поиска ближайших точек.
2. Загрузите данные из файла 'cars.csv' в DataFrame.
3. Создайте скаттерограмму, используя функцию scatterplot из Seaborn, с 'Year' на оси x, 'Distance' на оси y и 'Transmission' для цветового кодирования (hue).
4. Используйте KDTree, чтобы найти ближайшую точку к координатам (1980, 500000).
5. Извлеките тип Transmission для этой ближайшей точки и выведите его.

6. Представим, что вы визуализировали некий набор данных (рис. 2.10). 
Какие новые признаки, основанные на имеющихся, необходимо сконструировать, чтобы иметь возможность отделить все красные точки от всех синих точек с помощью прямой линии?

-При анализе нового признака, основанного на координатах, для левого графика красные данные будут иметь отрицательные значения перемноженных координат, а синие — положительные. Это позволяет использовать новую характеристику для разделения данных линией.
 Для правого графика можно рассчитать расстояние до начала координат с помощью формулы ( d = \sqrt{x^2 + y^2} ). Найдите максимальное расстояние для красных и минимальное для синих признаков, чтобы также разделить их линией.
