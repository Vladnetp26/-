1. Дискретные числовые признаки характеризуются ограниченным набором значений, таких как количество детей в семье или категория пола. В отличие от них, непрерывные числовые признаки могут принимать любое значение в пределах определенного диапазона, например, рост или вес человека.

2. Обучение с учителем подразумевает использование размеченных данных для обучения модели, где каждый пример уже отнесен к определенному классу или имеет известное значение. Напротив, обучение без учителя работает с неразмеченными данными, оставляя модель самой находить структуры и связи в данных.

3. Задачи классификации требуют от модели отнесения входных данных к одному из заранее определенных классов, например, определение пола по фотографии или фильтрация спама. Задачи регрессии, напротив, направлены на предсказание конкретного числового значения, такого как стоимость недвижимости на основе ее характеристик.

4. Определение, является ли изображение кошкой или собакой, представляет собой пример задачи классификации в области машинного обучения.

5. Оценка модели на валидационных данных позволяет проверить ее способность адаптироваться к новым данным, что важно для предотвращения переобучения, когда модель слишком сильно адаптируется к обучающим данным и теряет способность к обобщению.
  - A (5x4) и B (4x6) -> результат: матрица 5x6
    - A (5x4) и C (3x5) -> перемножение невозможно, так как число столбцов в первой матрице не равно числу строк во второй.
    - B (4x6) и C (3x5) -> перемножение невозможно, так как число столбцов в первой матрице не равно числу строк во второй.

7.Чтобы найти градиент функции f(x, y, z) = y*x^2 + ln(y) + e^-z, необходимо вычислить частные производные функции по каждой из переменных x, y, z.

1) Чтобы найти частную производную f по x:
df/dx = d(y*x^2)/dx + d(ln(y))/dx + d(e^-z)/dx
df/dx = 2*y*x + 0 + 0
df/dx = 2*y*x

2) Чтобы найти частную производную f по y:
df/dy = d(y*x^2)/dy + d(ln(y))/dy + d(e^-z)/dy
df/dy = x^2 + (1/y) + 0
df/dy = x^2 + 1/y

3) Чтобы найти частную производную f по z:
df/dz = d(y*x^2)/dz + d(ln(y))/dz + d(e^-z)/dz
df/dz = 0 + 0 - e^-z
df/dz = -e^-z

Таким образом, градиент функции f(x, y, z) равен:
∇f(x, y, z) = [2*y*x, x^2 + 1/y, -e^-z]

Для вычисления градиента функции ( f(x, y, z) = y \cdot x^2 + \ln(y) + e^{-z} ) в Python, можно использовать библиотеку numpy для математических операций и sympy для символьных вычислений, которые позволят нам найти частные производные по переменным ( x ), ( y ), и ( z ).

import numpy as np
import sympy as sp

# Определяем символы
x, y, z = sp.symbols('x y z')

# Определяем функцию
f = y * x**2 + sp.log(y) + sp.exp(-z)

# Вычисляем частные производные
df_dx = sp.diff(f, x)
df_dy = sp.diff(f, y)
df_dz = sp.diff(f, z)

# Выводим результаты
print("Частная производная по x:", df_dx)
print("Частная производная по y:", df_dy)
print("Частная производная по z:", df_dz)

# Функция для вычисления градиента
def gradient(x_val, y_val, z_val):
    # Подставляем значения в производные
    grad_x = df_dx.subs({x: x_val, y: y_val, z: z_val})
    grad_y = df_dy.subs({x: x_val, y: y_val, z: z_val})
    grad_z = df_dz.subs({x: x_val, y: y_val, z: z_val})
    return np.array([grad_x, grad_y, grad_z])

# Пример значений для x, y, z
x_val, y_val, z_val = 1, 2, 3

# Вычисление и вывод градиента
grad = gradient(x_val, y_val, z_val)
print("Градиент функции f при x = {}, y = {}, z = {}:".format(x_val, y_val, z_val), grad)
## Пояснение кода: Вычисление градиента функции

Этот код демонстрирует использование библиотеки SymPy для символьного дифференцирования и вычисления градиента функции. 

**Разберем по шагам:**

1. **Импорт и определение символов:**
   - `from sympy import symbols, diff` импортирует необходимые функции из библиотеки SymPy.
   - `x, y, z = symbols('x y z')` определяет `x`, `y`, `z` как символьные переменные. Это значит, что SymPy будет рассматривать их как математические переменные, а не как числовые значения.

2. **Определение функции:**
   - `f = x**2 * y + z * sympy.sin(x*y)` определяет функцию `f` от трех переменных `x`, `y`, `z`. SymPy позволяет использовать стандартные математические операции и функции (например, `sin`) для определения функции.

3. **Вычисление частных производных:**
   - `df_dx = diff(f, x)` вычисляет частную производную функции `f` по `x`.
   - Аналогично, `df_dy` и `df_dz` вычисляют частные производные по `y` и `z` соответственно.

4. **Функция `gradient`:**
   - Эта функция принимает три аргумента: `x_val`, `y_val`, `z_val`.
   - Внутри функции происходит подстановка переданных значений в вычисленные ранее частные производные:
     - `df_dx_val = df_dx.subs({x: x_val, y: y_val, z: z_val})` и аналогично для `df_dy_val` и `df_dz_val`.
   - `return np.array([df_dx_val, df_dy_val, df_dz_val])` возвращает градиент функции в точке (`x_val`, `y_val`, `z_val`) в виде массива NumPy.

**В итоге, код:**

- Определяет функцию от нескольких переменных.
- Символьно вычисляет частные производные этой функции.
- Создает функцию `gradient`, которая принимает значения переменных и возвращает градиент функции в этой точке.

**Пример использования:**

```python
result = gradient(1, 2, 3)
print(result) 
```

Этот код вычислит градиент функции `f` в точке (1, 2, 3) и выведет результат в виде массива NumPy.
8.Чтобы найти частные производные сложной функции E по переменным w и b, мы можем использовать цепное правило дифференцирования.
Пусть y' = w*x + b.
Тогда E = (y' - y)^2.
Частная производная E по w равна:
dE/dw = d((y' - y)^2)/dw.
Используя цепное правило, мы получаем:
dE/dw = 2 * (y' - y) * dy'/dw.
Теперь нам нужно найти dy'/dw. Используя тот факт, что y' = w * x + b, мы получаем:
dy'/dw = x.
Подставляя это в предыдущее уравнение, мы получаем:
dE/dw = 2 * (y' - y) * x.
Частная производная E по b равна:
dE/db = d((y' - y)^2)/db.
Используя цепное правило, мы получаем:
dE/db = 2 * (y' - y) * dy'/db.
Теперь нам нужно найти dy'/db. Используя тот факт, что y' = w * x + b, мы получаем:
dy'/db = 1.
Подставляя это в предыдущее уравнение, мы получаем:
dE/db = 2 * (y' - y).
В Python вы можете вычислить эти производные, используя следующий код:
def dE_dw(y, y_prime, x):
    return 2 * (y_prime - y) * x
def dE_db(y, y_prime):
    return 2 * (y_prime - y)
Обратите внимание, что в этой реализации предполагается, что y, y_prime, x являются скалярными значениями. Если они являются векторами, вам нужно будет соответствующим образом изменить реализацию.

9.  Найдите частные производные сложной функции 
E = y*ln(y') + (1-y)*ln(1-y'), y'=1/(1+e^(-z)) по переменной z. e - это основание натурального логарифма, y' - это предсказание модели y

import sympy as sp
# Определение переменных
z = sp.symbols('z')
y = sp.symbols('y')
# Определение y'
y_prime = 1 / (1 + sp.exp(-z))
# Определение функции E
E = y * sp.log(y_prime) + (1 - y) * sp.log(1 - y_prime)
# Вычисление частной производной E по z
dE_dz = sp.diff(E, z)
# Упрощение выражения
dE_dz_simplified = sp.simplify(dE_dz)
print(f'Частная производная E по z: {dE_dz_simplified}')
Этот код использует библиотеку sympy для символического вычисления частной производной функции ( E ) по переменной ( z ). Вывод будет выглядеть следующим образом:

Частная производная E по z: y*(1 - 1/(1 + exp(-z))) - (1 - y)/(1 + exp(-z))
